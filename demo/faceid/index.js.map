{
  "version": 3,
  "sources": ["index.ts", "indexdb.ts", "face-tracker.ts"],
  "sourcesContent": ["/**\n * Human demo for browsers\n * @default Human Library\n * @summary <https://github.com/vladmandic/human>\n * @author <https://github.com/vladmandic>\n * @copyright <https://github.com/vladmandic>\n * @license MIT\n */\n\nimport * as H from '../../dist/human.esm.js'; // equivalent of @vladmandic/Human\nimport { FaceTracker, TrackedFace } from './face-tracker';\nimport * as indexDb from './indexdb'; // methods to deal with indexdb\n\nconst humanConfig: Partial<H.Config> = { // user configuration for human, used to fine-tune behavior\n  cacheSensitivity: 0.01,\n  modelBasePath: '../../models',\n  filter: { enabled: true, equalization: true }, // lets run with histogram equilizer\n  backend: 'humangl',\n  debug: true,\n  face: {\n    enabled: true,\n    detector: { maxDetected: 3, rotation: true, return: false, mask: false }, // no need to return tensors in realtime mode\n    description: { enabled: true }, // default model for face descriptor extraction is faceres\n    // mobilefacenet: { enabled: true, modelPath: 'https://vladmandic.github.io/human-models/models/mobilefacenet.json' }, // alternative model\n    // insightface: { enabled: true, modelPath: 'https://vladmandic.github.io/insightface/models/insightface-mobilenet-swish.json' }, // alternative model\n    iris: { enabled: false }, // iris disabled: operate without gaze/gesture\n    emotion: { enabled: false }, // not needed\n    // antispoof: { enabled: true }, // enable optional antispoof module\n    // liveness: { enabled: true }, // enable optional liveness module\n  },\n  body: { enabled: false },\n  hand: { enabled: false },\n  object: { enabled: false },\n  // gesture: { enabled: true }, // parses face and iris gestures\n};\n\n// const matchOptions = { order: 2, multiplier: 1000, min: 0.0, max: 1.0 }; // for embedding model\nconst matchOptions: H.match.MatchOptions = { order: 2, multiplier: 20, min: 0.1, max: 0.9 }; // for faceres model\n\nconst options = {\n  minConfidence: 0.6, // overal face confidence for box, face, gender, real, live\n  minSize: 224, // min input to face descriptor model before degradation\n  maxTime: 30000, // max time before giving up\n  blinkMin: 10, // minimum duration of a valid blink\n  blinkMax: 800, // maximum duration of a valid blink\n  threshold: 0.5, // minimum similarity\n  distanceMin: 0.4, // closest that face is allowed to be to the cammera in cm\n  distanceMax: 1.0, // farthest that face is allowed to be to the cammera in cm\n  mask: humanConfig.face?.detector?.mask,\n  rotation: humanConfig.face?.detector?.rotation,\n  ...matchOptions,\n};\n\n// Real-time mode: validation gates removed\n\nconst current: { face: H.FaceResult | null, record: indexDb.FaceRecord | null } = { face: null, record: null }; // backward-compatible current selection\nlet knownFaces: indexDb.FaceRecord[] = [];\nlet knownDescriptors: number[][] = [];\nlet faceTracker: FaceTracker;\n\n// gesture/iris disabled: remove blink and gaze-related state\n\n// let db: Array<{ name: string, source: string, embedding: number[] }> = []; // holds loaded face descriptor database\nconst human = new H.Human(humanConfig); // create instance of human with overrides from user configuration\n\nhuman.env.perfadd = false; // is performance data showing instant or total values\nhuman.draw.options.font = 'small-caps 18px \"Lato\"'; // set font used to draw labels when using draw methods\nhuman.draw.options.lineHeight = 20;\n\nconst dom = { // grab instances of dom objects so we dont have to look them up later\n  video: document.getElementById('video') as HTMLVideoElement,\n  canvas: document.getElementById('canvas') as HTMLCanvasElement,\n  log: document.getElementById('log') as HTMLPreElement,\n  fps: document.getElementById('fps') as HTMLPreElement,\n  match: document.getElementById('match') as HTMLDivElement,\n  matches: document.getElementById('matches') as HTMLDivElement,\n  name: document.getElementById('name') as HTMLInputElement,\n  save: document.getElementById('save') as HTMLSpanElement,\n  delete: document.getElementById('delete') as HTMLSpanElement,\n  source: document.getElementById('source') as HTMLCanvasElement,\n};\nconst timestamp = { detect: 0, draw: 0 }; // holds information used to calculate performance and possible memory leaks\nlet startTime = 0;\n\nconst log = (...msg) => { // helper method to output messages\n  dom.log.innerText += msg.join(' ') + '\\n';\n  console.log(...msg); // eslint-disable-line no-console\n};\n\nfunction getFaceCropImageData(video: HTMLVideoElement, box: [number, number, number, number], size = 128): ImageData {\n  const [bx, by, bw, bh] = box;\n  const sx = Math.max(0, Math.floor(bx));\n  const sy = Math.max(0, Math.floor(by));\n  const sw = Math.max(1, Math.min(video.videoWidth - sx, Math.floor(bw)));\n  const sh = Math.max(1, Math.min(video.videoHeight - sy, Math.floor(bh)));\n  const off = document.createElement('canvas');\n  off.width = size; off.height = size;\n  const octx = off.getContext('2d') as CanvasRenderingContext2D;\n  octx.imageSmoothingEnabled = true;\n  octx.imageSmoothingQuality = 'high';\n  octx.drawImage(video, sx, sy, sw, sh, 0, 0, size, size);\n  return octx.getImageData(0, 0, size, size);\n}\n\nasync function webCam() { // initialize webcam\n  // @ts-ignore resizeMode is not yet defined in tslib\n  const cameraOptions: MediaStreamConstraints = { audio: false, video: { facingMode: 'user', resizeMode: 'none', width: { ideal: document.body.clientWidth } } };\n  const stream: MediaStream = await navigator.mediaDevices.getUserMedia(cameraOptions);\n  const ready = new Promise((resolve) => { dom.video.onloadeddata = () => resolve(true); });\n  dom.video.srcObject = stream;\n  void dom.video.play();\n  await ready;\n  // set canvas internal size to match video pixels\n  dom.canvas.width = dom.video.videoWidth;\n  dom.canvas.height = dom.video.videoHeight;\n  // ensure canvas CSS size tracks the video's rendered size\n  const stage = document.getElementById('stage') as HTMLDivElement | null;\n  if (stage) {\n    const resize = () => {\n      // canvas is absolutely positioned with width/height 100% in CSS, so nothing else required\n      // but some browsers need a reflow to sync; toggling transform forces it\n      dom.canvas.style.transform = 'translateZ(0)';\n    };\n    new ResizeObserver(resize).observe(stage);\n    resize();\n  }\n  if (human.env.initial) log('video:', dom.video.videoWidth, dom.video.videoHeight, '|', stream.getVideoTracks()[0].label);\n  dom.canvas.onclick = () => { // pause when clicked on screen and resume on next click\n    if (dom.video.paused) void dom.video.play();\n    else dom.video.pause();\n  };\n}\n\nasync function detectionLoop() { // main detection + render + match loop\n  if (dom.video.paused) return;\n  await human.detect(dom.video);\n  const interpolated = human.next(human.result);\n  const ctx = dom.canvas.getContext('2d');\n  ctx?.clearRect(0, 0, dom.canvas.width, dom.canvas.height);\n  \n  // Process faces through tracker\n  const faces = interpolated.face.slice(0, 3);\n  const { newlyRegistered, updates } = await faceTracker.processFaces(faces);\n  \n  // Handle newly registered faces\n  if (newlyRegistered.length > 0) {\n    await refreshKnownFaces(); // Refresh known faces after auto-registration\n    faceTracker.updateKnownFaces(knownDescriptors, knownFaces);\n    for (const registered of newlyRegistered) {\n      log('\uC790\uB3D9 \uB4F1\uB85D\uB428:', registered.matchedRecord?.name || 'Unknown');\n    }\n  }\n  \n  const labels: string[] = [];\n  const matchedRecs: Array<indexDb.FaceRecord | null> = [];\n  const trackedFaces = faceTracker.getTrackedFaces();\n  \n  if (ctx) {\n    ctx.save();\n    ctx.font = '16px Lato';\n    ctx.fillStyle = 'white';\n    ctx.strokeStyle = 'black';\n    ctx.lineWidth = 2;\n  }\n  \n  let primaryBest = null as null | { name: string, similarity: number, record: indexDb.FaceRecord };\n  \n  for (let i = 0; i < faces.length; i += 1) {\n    const f = faces[i];\n    let label = 'unknown';\n    let matchedRec: indexDb.FaceRecord | null = null;\n    \n    // Find corresponding tracked face\n    const tracked = trackedFaces.find(tf => \n      tf.face.box && f.box && \n      Math.abs(tf.face.box[0] - f.box[0]) < 50 && \n      Math.abs(tf.face.box[1] - f.box[1]) < 50\n    );\n    \n    if (tracked) {\n      if (tracked.isMatched && tracked.matchedRecord) {\n        matchedRec = tracked.matchedRecord;\n        label = `${tracked.matchedRecord.name}`;\n        if (!primaryBest) primaryBest = { name: tracked.matchedRecord.name, similarity: 1.0, record: tracked.matchedRecord };\n      } else {\n        // Show tracking progress for unknown faces\n        const progress = Math.min(tracked.trackingDuration / 5000, 1.0);\n        const remaining = Math.max(0, 5000 - tracked.trackingDuration);\n        label = `\uCD94\uC801\uC911 ${(progress * 100).toFixed(0)}% (${(remaining / 1000).toFixed(1)}s)`;\n      }\n    }\n    \n    // Draw box and label\n    if (ctx && f.box) {\n      const [x, y, w, h] = f.box as [number, number, number, number];\n      \n      // Color based on tracking status\n      if (tracked?.isMatched) {\n        ctx.strokeStyle = 'lime'; // Known face\n      } else if (tracked) {\n        const progress = Math.min(tracked.trackingDuration / 5000, 1.0);\n        ctx.strokeStyle = `rgb(${255 - Math.round(progress * 255)}, ${Math.round(progress * 255)}, 0)`; // Red to Green\n      } else {\n        ctx.strokeStyle = 'red'; // New/untracked face\n      }\n      \n      ctx.strokeRect(x, y, w, h);\n      const ty = Math.max(0, y - 6);\n      ctx.strokeStyle = 'black';\n      ctx.strokeText(label, x, ty);\n      ctx.fillText(label, x, ty);\n    }\n    \n    labels.push(label);\n    matchedRecs.push(matchedRec);\n  }\n  \n  // Update current selection\n  current.face = faces.sort((a, b) => (b.box[2] * b.box[3]) - (a.box[2] * a.box[3]))[0] || null;\n  current.record = primaryBest ? primaryBest.record : null;\n  \n  // Update UI\n  updateMatchesUI(faces, labels, matchedRecs, trackedFaces);\n  \n  const now = human.now();\n  timestamp.detect = now;\n  requestAnimationFrame(detectionLoop);\n}\n\nfunction updateMatchesUI(faces: H.FaceResult[], labels: string[], matchedRecs: Array<indexDb.FaceRecord | null>, trackedFaces: TrackedFace[]) {\n  if (!dom.matches) return;\n  \n  dom.matches.innerHTML = '';\n  \n  if (faces.length === 0) {\n    dom.matches.innerText = 'no faces detected';\n    return;\n  }\n  \n  faces.forEach((f, i) => {\n    const row = document.createElement('div');\n    row.style.display = 'flex';\n    row.style.alignItems = 'center';\n    row.style.gap = '8px';\n    row.style.margin = '4px 0';\n    \n    const text = document.createElement('div');\n    text.innerText = `face ${i + 1}: ${labels[i] || 'unknown'}`;\n    row.appendChild(text);\n    \n    // Find tracked face info\n    const tracked = trackedFaces.find(tf => \n      tf.face.box && f.box && \n      Math.abs(tf.face.box[0] - f.box[0]) < 50 && \n      Math.abs(tf.face.box[1] - f.box[1]) < 50\n    );\n    \n    // Show tracking status\n    if (tracked && !tracked.isMatched) {\n      const status = document.createElement('div');\n      status.style.fontSize = '12px';\n      status.style.color = '#888';\n      const remaining = Math.max(0, 5000 - tracked.trackingDuration);\n      status.innerText = `(${(remaining / 1000).toFixed(1)}\uCD08 \uD6C4 \uC790\uB3D9 \uB4F1\uB85D)`;\n      row.appendChild(status);\n    }\n    \n    // Live crop from video\n    if (f.box && dom.video.videoWidth > 0) {\n      const [bx, by, bw, bh] = f.box as [number, number, number, number];\n      const sx = Math.max(0, Math.floor(bx));\n      const sy = Math.max(0, Math.floor(by));\n      const sw = Math.min(dom.video.videoWidth - sx, Math.floor(bw));\n      const sh = Math.min(dom.video.videoHeight - sy, Math.floor(bh));\n      const live = document.createElement('canvas');\n      live.width = 96; live.height = 96;\n      const lctx = live.getContext('2d');\n      if (lctx && sw > 0 && sh > 0) lctx.drawImage(dom.video, sx, sy, sw, sh, 0, 0, 96, 96);\n      row.appendChild(live);\n    }\n    \n    // Show stored image if matched\n    const rec = matchedRecs[i];\n    if (rec?.image) {\n      const c = document.createElement('canvas');\n      c.width = rec.image.width;\n      c.height = rec.image.height;\n      c.style.width = '96px';\n      c.style.height = '96px';\n      const cctx = c.getContext('2d');\n      cctx?.putImageData(rec.image, 0, 0);\n      row.appendChild(c);\n    }\n    \n    dom.matches.appendChild(row);\n  });\n}\n\n// validation removed\n\nasync function saveRecords() {\n  if (dom.name.value.length > 0) {\n    // choose the largest detected face for saving\n    const faces = human.result.face;\n    const faceToSave = faces.sort((a, b) => (b.box[2] * b.box[3]) - (a.box[2] * a.box[3]))[0];\n    if (!faceToSave?.embedding) { log('no face embedding to save'); return; }\n    const image = getFaceCropImageData(dom.video, faceToSave.box as [number, number, number, number], 128);\n    const rec = { id: 0, name: dom.name.value, descriptor: faceToSave.embedding as number[], image };\n    await indexDb.save(rec);\n    await refreshKnownFaces();\n    log('saved face record:', rec.name, 'descriptor length:', (faceToSave.embedding?.length || 0));\n    log('known face records:', knownFaces.length);\n  } else {\n    log('invalid name');\n  }\n}\n\nasync function deleteRecord() {\n  if (current.record && current.record.id > 0) {\n    await indexDb.remove(current.record);\n    await refreshKnownFaces();\n  }\n}\n\n// detectFace flow removed; handled in detectionLoop per-frame\n\nasync function main() { // main entry point for continuous mode\n  dom.match.style.display = 'flex';\n  dom.save.style.display = 'flex';\n  dom.delete.style.display = 'flex';\n  dom.source.style.display = 'none';\n  dom.canvas.style.height = '';\n  document.body.style.background = 'black';\n  if (dom.video.paused) void dom.video.play();\n  await detectionLoop();\n}\n\nasync function init() {\n  log('human version:', human.version, '| tfjs version:', human.tf.version['tfjs-core']);\n  log('options:', JSON.stringify(options).replace(/{|}|\"|\\[|\\]/g, '').replace(/,/g, ' '));\n  log('initializing webcam...');\n  await webCam(); // start webcam\n  log('loading human models...');\n  await human.load(); // preload all models\n  log('initializing human...');\n  log('loading face database...');\n  await refreshKnownFaces();\n  \n  // Initialize face tracker\n  faceTracker = new FaceTracker(knownDescriptors, knownFaces, matchOptions, human);\n  log('face tracker initialized');\n  \n  dom.save.addEventListener('click', saveRecords);\n  dom.delete.addEventListener('click', deleteRecord);\n  await human.warmup(); // warmup function to initialize backend for future faster detection\n  await main();\n}\n\nwindow.onload = init;\n\nasync function refreshKnownFaces() {\n  knownFaces = await indexDb.load();\n  knownDescriptors = knownFaces.map((rec) => rec.descriptor).filter((d) => d.length > 0);\n  log('known face records:', knownFaces.length);\n}\n", "let db: IDBDatabase; // instance of indexdb\n\nconst database = 'human';\nconst table = 'person';\n\nexport interface FaceRecord { id: number, name: string, descriptor: number[], image: ImageData }\n\nconst log = (...msg) => console.log('indexdb', ...msg); // eslint-disable-line no-console\n\nexport async function open() {\n  if (db) return true;\n  return new Promise((resolve) => {\n    const request: IDBOpenDBRequest = indexedDB.open(database, 1);\n    request.onerror = (evt) => log('error:', evt);\n    request.onupgradeneeded = (evt: IDBVersionChangeEvent) => { // create if doesnt exist\n      log('create:', evt.target);\n      db = (evt.target as IDBOpenDBRequest).result;\n      db.createObjectStore(table, { keyPath: 'id', autoIncrement: true });\n    };\n    request.onsuccess = (evt) => { // open\n      db = (evt.target as IDBOpenDBRequest).result;\n      log('open:', db);\n      resolve(true);\n    };\n  });\n}\n\nexport async function load(): Promise<FaceRecord[]> {\n  const faceDB: FaceRecord[] = [];\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const cursor: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).openCursor(null, 'next');\n    cursor.onerror = (evt) => log('load error:', evt);\n    cursor.onsuccess = (evt) => {\n      if ((evt.target as IDBRequest).result) {\n        faceDB.push((evt.target as IDBRequest).result.value);\n        (evt.target as IDBRequest).result.continue();\n      } else {\n        resolve(faceDB);\n      }\n    };\n  });\n}\n\nexport async function count(): Promise<number> {\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const store: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).count();\n    store.onerror = (evt) => log('count error:', evt);\n    store.onsuccess = () => resolve(store.result);\n  });\n}\n\nexport async function save(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  const newRecord = { name: faceRecord.name, descriptor: faceRecord.descriptor, image: faceRecord.image }; // omit id as its autoincrement\n  db.transaction([table], 'readwrite').objectStore(table).put(newRecord);\n  log('save:', newRecord);\n}\n\nexport async function remove(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  db.transaction([table], 'readwrite').objectStore(table).delete(faceRecord.id); // delete based on id\n  log('delete:', faceRecord);\n}\n", "/**\n * Face tracking system for automatic registration\n */\n\nimport * as H from '../../dist/human.esm.js';\nimport * as indexDb from './indexdb';\n\nexport interface TrackedFace {\n  id: string;\n  face: H.FaceResult;\n  firstSeen: number;\n  lastSeen: number;\n  trackingDuration: number;\n  isMatched: boolean;\n  matchedRecord?: indexDb.FaceRecord;\n}\n\nexport class FaceTracker {\n  private trackedFaces = new Map<string, TrackedFace>();\n  private readonly trackingThreshold = 5000; // 5 seconds\n  private readonly similarityThreshold = 0.6; // threshold for considering faces as same person\n  private readonly autoSaveEnabled = true;\n\n  constructor(\n    private knownDescriptors: number[][],\n    private knownFaces: indexDb.FaceRecord[],\n    private matchOptions: H.match.MatchOptions,\n    private human: H.Human\n  ) {}\n\n  updateKnownFaces(descriptors: number[][], faces: indexDb.FaceRecord[]) {\n    this.knownDescriptors = descriptors;\n    this.knownFaces = faces;\n  }\n\n  private generateFaceId(face: H.FaceResult): string {\n    // Generate simple ID based on face position and size\n    if (!face.box) return Math.random().toString();\n    const [x, y, w, h] = face.box;\n    return `${Math.round(x)}_${Math.round(y)}_${Math.round(w)}_${Math.round(h)}`;\n  }\n\n  private isSameFace(face1: H.FaceResult, face2: H.FaceResult): boolean {\n    if (!face1.box || !face2.box) return false;\n    \n    const [x1, y1, w1, h1] = face1.box;\n    const [x2, y2, w2, h2] = face2.box;\n    \n    // Check if faces are in similar position and size\n    const positionThreshold = 50;\n    const sizeThreshold = 30;\n    \n    return Math.abs(x1 - x2) < positionThreshold &&\n           Math.abs(y1 - y2) < positionThreshold &&\n           Math.abs(w1 - w2) < sizeThreshold &&\n           Math.abs(h1 - h2) < sizeThreshold;\n  }\n\n  private findMatchingKnownFace(face: H.FaceResult): { record: indexDb.FaceRecord; similarity: number } | null {\n    if (!face.embedding || face.embedding.length === 0 || this.knownDescriptors.length === 0) {\n      return null;\n    }\n\n    const res = this.human.match.find(face.embedding, this.knownDescriptors, this.matchOptions);\n    const record = this.knownFaces[res.index];\n    \n    if (record && res.similarity > this.similarityThreshold) { // threshold for considering a match\n      return { record, similarity: res.similarity };\n    }\n    \n    return null;\n  }\n\n  async processFaces(faces: H.FaceResult[]): Promise<{ newlyRegistered: TrackedFace[], updates: TrackedFace[] }> {\n    const now = Date.now();\n    const currentFaceIds = new Set<string>();\n    const newlyRegistered: TrackedFace[] = [];\n    const updates: TrackedFace[] = [];\n\n    // Process each detected face\n    for (const face of faces) {\n      if (!face.embedding || face.embedding.length === 0) continue;\n\n      // Check if face matches known faces\n      const matchResult = this.findMatchingKnownFace(face);\n      const isMatched = matchResult !== null;\n\n      // Find existing tracked face or create new one\n      let trackedFace: TrackedFace | null = null;\n      \n      // Try to find existing tracked face by similarity\n      for (const [id, tracked] of this.trackedFaces) {\n        if (this.isSameFace(face, tracked.face)) {\n          trackedFace = tracked;\n          currentFaceIds.add(id);\n          break;\n        }\n      }\n\n      if (!trackedFace) {\n        // Create new tracked face\n        const id = this.generateFaceId(face);\n        trackedFace = {\n          id,\n          face,\n          firstSeen: now,\n          lastSeen: now,\n          trackingDuration: 0,\n          isMatched,\n          matchedRecord: matchResult?.record\n        };\n        this.trackedFaces.set(id, trackedFace);\n        currentFaceIds.add(id);\n      } else {\n        // Update existing tracked face\n        trackedFace.face = face;\n        trackedFace.lastSeen = now;\n        trackedFace.trackingDuration = now - trackedFace.firstSeen;\n        trackedFace.isMatched = isMatched;\n        trackedFace.matchedRecord = matchResult?.record;\n      }\n\n      // Check if unknown face should be auto-registered\n      if (!trackedFace.isMatched && \n          trackedFace.trackingDuration >= this.trackingThreshold && \n          this.autoSaveEnabled) {\n        \n        await this.autoRegisterFace(trackedFace);\n        newlyRegistered.push(trackedFace);\n      }\n\n      updates.push(trackedFace);\n    }\n\n    // Remove faces that are no longer detected\n    for (const [id, tracked] of this.trackedFaces) {\n      if (!currentFaceIds.has(id)) {\n        // Face not seen for a while, remove it\n        if (now - tracked.lastSeen > 2000) { // 2 second timeout\n          this.trackedFaces.delete(id);\n        }\n      }\n    }\n\n    return { newlyRegistered, updates };\n  }\n\n  private async autoRegisterFace(trackedFace: TrackedFace) {\n    try {\n      // Generate automatic name\n      const timestamp = new Date().toLocaleString('ko-KR');\n      const autoName = `Unknown_${timestamp}`;\n\n      // Get face crop for image storage\n      const image = this.getFaceCropImageData(trackedFace.face);\n      \n      const record: indexDb.FaceRecord = {\n        id: 0, // will be auto-incremented\n        name: autoName,\n        descriptor: trackedFace.face.embedding as number[],\n        image\n      };\n\n      await indexDb.save(record);\n      \n      // Mark as matched to prevent re-registration\n      trackedFace.isMatched = true;\n      \n      console.log('Auto-registered face:', autoName);\n    } catch (error) {\n      console.error('Failed to auto-register face:', error);\n    }\n  }\n\n  private getFaceCropImageData(face: H.FaceResult): ImageData {\n    if (!face.box) {\n      // Return empty ImageData if no box\n      const canvas = document.createElement('canvas');\n      canvas.width = canvas.height = 128;\n      const ctx = canvas.getContext('2d')!;\n      return ctx.getImageData(0, 0, 128, 128);\n    }\n\n    const video = document.getElementById('video') as HTMLVideoElement;\n    const [bx, by, bw, bh] = face.box as [number, number, number, number];\n    const sx = Math.max(0, Math.floor(bx));\n    const sy = Math.max(0, Math.floor(by));\n    const sw = Math.max(1, Math.min(video.videoWidth - sx, Math.floor(bw)));\n    const sh = Math.max(1, Math.min(video.videoHeight - sy, Math.floor(bh)));\n    \n    const canvas = document.createElement('canvas');\n    canvas.width = canvas.height = 128;\n    const ctx = canvas.getContext('2d')!;\n    \n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high';\n    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, 128, 128);\n    \n    return ctx.getImageData(0, 0, 128, 128);\n  }\n\n  getTrackedFaces(): TrackedFace[] {\n    return Array.from(this.trackedFaces.values());\n  }\n\n  getTrackingInfo(faceId: string): TrackedFace | null {\n    return this.trackedFaces.get(faceId) || null;\n  }\n}"],
  "mappings": "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",
  "names": ["H", "db", "database", "table", "log", "msg", "open", "resolve", "request", "evt", "load", "faceDB", "cursor", "save", "faceRecord", "db", "open", "newRecord", "table", "log", "remove", "FaceTracker", "knownDescriptors", "knownFaces", "matchOptions", "human", "__publicField", "descriptors", "faces", "face", "x", "y", "w", "h", "face1", "face2", "x1", "y1", "w1", "h1", "x2", "y2", "w2", "h2", "positionThreshold", "sizeThreshold", "res", "record", "now", "currentFaceIds", "newlyRegistered", "updates", "matchResult", "isMatched", "trackedFace", "id", "tracked", "autoName", "image", "save", "error", "canvas", "video", "bx", "by", "bw", "bh", "sx", "sy", "sw", "sh", "ctx", "faceId", "humanConfig", "matchOptions", "_a", "_b", "_c", "_d", "options", "current", "knownFaces", "knownDescriptors", "faceTracker", "human", "dom", "timestamp", "log", "msg", "dom", "getFaceCropImageData", "video", "box", "size", "bx", "by", "bw", "bh", "sx", "sy", "sw", "sh", "off", "octx", "webCam", "cameraOptions", "stream", "ready", "resolve", "stage", "resize", "human", "detectionLoop", "_a", "interpolated", "ctx", "faces", "newlyRegistered", "updates", "faceTracker", "refreshKnownFaces", "knownDescriptors", "knownFaces", "registered", "labels", "matchedRecs", "trackedFaces", "primaryBest", "i", "f", "label", "matchedRec", "tracked", "tf", "progress", "remaining", "x", "y", "w", "h", "ty", "current", "a", "b", "updateMatchesUI", "now", "timestamp", "row", "text", "status", "live", "lctx", "rec", "c", "cctx", "saveRecords", "faceToSave", "image", "save", "deleteRecord", "remove", "main", "init", "options", "FaceTracker", "matchOptions", "load", "d"]
}
