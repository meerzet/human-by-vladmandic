{
  "version": 3,
  "sources": ["index.ts", "indexdb.ts", "face-tracker.ts"],
  "sourcesContent": ["/**\n * Human demo for browsers\n * @default Human Library\n * @summary <https://github.com/vladmandic/human>\n * @author <https://github.com/vladmandic>\n * @copyright <https://github.com/vladmandic>\n * @license MIT\n */\n\nimport * as H from '../../dist/human.esm.js'; // equivalent of @vladmandic/Human\nimport { FaceTracker, TrackedFace } from './face-tracker';\nimport * as indexDb from './indexdb'; // methods to deal with indexdb\n\nconst humanConfig: Partial<H.Config> = { // user configuration for human, used to fine-tune behavior\n  cacheSensitivity: 0.01,\n  modelBasePath: '../../models',\n  filter: { enabled: true, equalization: true }, // lets run with histogram equilizer\n  backend: 'humangl',\n  debug: true,\n  face: {\n    enabled: true,\n    detector: { maxDetected: 3, rotation: true, return: false, mask: false }, // no need to return tensors in realtime mode\n    description: { enabled: true }, // default model for face descriptor extraction is faceres\n    // mobilefacenet: { enabled: true, modelPath: 'https://vladmandic.github.io/human-models/models/mobilefacenet.json' }, // alternative model\n    // insightface: { enabled: true, modelPath: 'https://vladmandic.github.io/insightface/models/insightface-mobilenet-swish.json' }, // alternative model\n    iris: { enabled: false }, // iris disabled: operate without gaze/gesture\n    emotion: { enabled: false }, // not needed\n    // antispoof: { enabled: true }, // enable optional antispoof module\n    // liveness: { enabled: true }, // enable optional liveness module\n  },\n  body: { enabled: false },\n  hand: { enabled: false },\n  object: { enabled: false },\n  // gesture: { enabled: true }, // parses face and iris gestures\n};\n\n// const matchOptions = { order: 2, multiplier: 1000, min: 0.0, max: 1.0 }; // for embedding model\nconst matchOptions: H.match.MatchOptions = { order: 2, multiplier: 20, min: 0.1, max: 0.9 }; // for faceres model\n\nconst options = {\n  minConfidence: 0.6, // overal face confidence for box, face, gender, real, live\n  minSize: 224, // min input to face descriptor model before degradation\n  maxTime: 30000, // max time before giving up\n  blinkMin: 10, // minimum duration of a valid blink\n  blinkMax: 800, // maximum duration of a valid blink\n  threshold: 0.5, // minimum similarity\n  distanceMin: 0.4, // closest that face is allowed to be to the cammera in cm\n  distanceMax: 1.0, // farthest that face is allowed to be to the cammera in cm\n  mask: humanConfig.face?.detector?.mask,\n  rotation: humanConfig.face?.detector?.rotation,\n  ...matchOptions,\n};\n\n// Real-time mode: validation gates removed\n\nconst current: { face: H.FaceResult | null, record: indexDb.FaceRecord | null } = { face: null, record: null }; // backward-compatible current selection\nlet knownFaces: indexDb.FaceRecord[] = [];\nlet knownDescriptors: number[][] = [];\nlet faceTracker: FaceTracker;\n\n// gesture/iris disabled: remove blink and gaze-related state\n\n// let db: Array<{ name: string, source: string, embedding: number[] }> = []; // holds loaded face descriptor database\nconst human = new H.Human(humanConfig); // create instance of human with overrides from user configuration\n\nhuman.env.perfadd = false; // is performance data showing instant or total values\nhuman.draw.options.font = 'small-caps 18px \"Lato\"'; // set font used to draw labels when using draw methods\nhuman.draw.options.lineHeight = 20;\n\nconst dom = { // grab instances of dom objects so we dont have to look them up later\n  video: document.getElementById('video') as HTMLVideoElement,\n  canvas: document.getElementById('canvas') as HTMLCanvasElement,\n  log: document.getElementById('log') as HTMLPreElement,\n  fps: document.getElementById('fps') as HTMLPreElement,\n  match: document.getElementById('match') as HTMLDivElement,\n  matches: document.getElementById('matches') as HTMLDivElement,\n  name: document.getElementById('name') as HTMLInputElement,\n  save: document.getElementById('save') as HTMLSpanElement,\n  delete: document.getElementById('delete') as HTMLSpanElement,\n  source: document.getElementById('source') as HTMLCanvasElement,\n};\nconst timestamp = { detect: 0, draw: 0 }; // holds information used to calculate performance and possible memory leaks\nlet startTime = 0;\n\nconst log = (...msg) => { // helper method to output messages\n  dom.log.innerText += msg.join(' ') + '\\n';\n  console.log(...msg); // eslint-disable-line no-console\n};\n\nfunction getFaceCropImageData(video: HTMLVideoElement, box: [number, number, number, number], size = 128): ImageData {\n  const [bx, by, bw, bh] = box;\n  const sx = Math.max(0, Math.floor(bx));\n  const sy = Math.max(0, Math.floor(by));\n  const sw = Math.max(1, Math.min(video.videoWidth - sx, Math.floor(bw)));\n  const sh = Math.max(1, Math.min(video.videoHeight - sy, Math.floor(bh)));\n  const off = document.createElement('canvas');\n  off.width = size; off.height = size;\n  const octx = off.getContext('2d') as CanvasRenderingContext2D;\n  octx.imageSmoothingEnabled = true;\n  octx.imageSmoothingQuality = 'high';\n  octx.drawImage(video, sx, sy, sw, sh, 0, 0, size, size);\n  return octx.getImageData(0, 0, size, size);\n}\n\nasync function webCam() { // initialize webcam\n  // @ts-ignore resizeMode is not yet defined in tslib\n  const cameraOptions: MediaStreamConstraints = { audio: false, video: { facingMode: 'user', resizeMode: 'none', width: { ideal: document.body.clientWidth } } };\n  const stream: MediaStream = await navigator.mediaDevices.getUserMedia(cameraOptions);\n  const ready = new Promise((resolve) => { dom.video.onloadeddata = () => resolve(true); });\n  dom.video.srcObject = stream;\n  void dom.video.play();\n  await ready;\n  // set canvas internal size to match video pixels\n  dom.canvas.width = dom.video.videoWidth;\n  dom.canvas.height = dom.video.videoHeight;\n  // ensure canvas CSS size tracks the video's rendered size\n  const stage = document.getElementById('stage') as HTMLDivElement | null;\n  if (stage) {\n    const resize = () => {\n      // canvas is absolutely positioned with width/height 100% in CSS, so nothing else required\n      // but some browsers need a reflow to sync; toggling transform forces it\n      dom.canvas.style.transform = 'translateZ(0)';\n    };\n    new ResizeObserver(resize).observe(stage);\n    resize();\n  }\n  if (human.env.initial) log('video:', dom.video.videoWidth, dom.video.videoHeight, '|', stream.getVideoTracks()[0].label);\n  dom.canvas.onclick = () => { // pause when clicked on screen and resume on next click\n    if (dom.video.paused) void dom.video.play();\n    else dom.video.pause();\n  };\n}\n\nasync function detectionLoop() { // main detection + render + match loop\n  if (dom.video.paused) return;\n  await human.detect(dom.video);\n  const interpolated = human.next(human.result);\n  const ctx = dom.canvas.getContext('2d');\n  ctx?.clearRect(0, 0, dom.canvas.width, dom.canvas.height);\n  \n  // Process faces through tracker\n  const faces = interpolated.face.slice(0, 3);\n  const { newlyRegistered, updates } = await faceTracker.processFaces(faces);\n  \n  // Handle newly registered faces\n  if (newlyRegistered.length > 0) {\n    await refreshKnownFaces(); // Refresh known faces after auto-registration\n    faceTracker.updateKnownFaces(knownDescriptors, knownFaces);\n    for (const registered of newlyRegistered) {\n      log('\uC790\uB3D9 \uB4F1\uB85D\uB428:', registered.matchedRecord?.name || 'Unknown');\n    }\n  }\n  \n  const labels: string[] = [];\n  const matchedRecs: Array<indexDb.FaceRecord | null> = [];\n  const trackedFaces = faceTracker.getTrackedFaces();\n  \n  if (ctx) {\n    ctx.save();\n    ctx.font = '16px Lato';\n    ctx.fillStyle = 'white';\n    ctx.strokeStyle = 'black';\n    ctx.lineWidth = 2;\n  }\n  \n  let primaryBest = null as null | { name: string, similarity: number, record: indexDb.FaceRecord };\n  \n  for (let i = 0; i < faces.length; i += 1) {\n    const f = faces[i];\n    let label = 'unknown';\n    let matchedRec: indexDb.FaceRecord | null = null;\n    \n    // Find corresponding tracked face\n    const tracked = trackedFaces.find(tf => \n      tf.face.box && f.box && \n      Math.abs(tf.face.box[0] - f.box[0]) < 50 && \n      Math.abs(tf.face.box[1] - f.box[1]) < 50\n    );\n    \n    if (tracked) {\n      if (tracked.isMatched && tracked.matchedRecord) {\n        matchedRec = tracked.matchedRecord;\n        label = `${tracked.matchedRecord.name}`;\n        if (!primaryBest) primaryBest = { name: tracked.matchedRecord.name, similarity: 1.0, record: tracked.matchedRecord };\n      } else {\n        // Show tracking progress for unknown faces\n        const progress = Math.min(tracked.trackingDuration / 5000, 1.0);\n        const remaining = Math.max(0, 5000 - tracked.trackingDuration);\n        label = `\uCD94\uC801\uC911 ${(progress * 100).toFixed(0)}% (${(remaining / 1000).toFixed(1)}s)`;\n      }\n    }\n    \n    // Draw box and label\n    if (ctx && f.box) {\n      const [x, y, w, h] = f.box as [number, number, number, number];\n      \n      // Color based on tracking status\n      if (tracked?.isMatched) {\n        ctx.strokeStyle = 'lime'; // Known face\n      } else if (tracked) {\n        const progress = Math.min(tracked.trackingDuration / 5000, 1.0);\n        ctx.strokeStyle = `rgb(${255 - Math.round(progress * 255)}, ${Math.round(progress * 255)}, 0)`; // Red to Green\n      } else {\n        ctx.strokeStyle = 'red'; // New/untracked face\n      }\n      \n      ctx.strokeRect(x, y, w, h);\n      const ty = Math.max(0, y - 6);\n      ctx.strokeStyle = 'black';\n      ctx.strokeText(label, x, ty);\n      ctx.fillText(label, x, ty);\n    }\n    \n    labels.push(label);\n    matchedRecs.push(matchedRec);\n  }\n  \n  // Update current selection\n  current.face = faces.sort((a, b) => (b.box[2] * b.box[3]) - (a.box[2] * a.box[3]))[0] || null;\n  current.record = primaryBest ? primaryBest.record : null;\n  \n  // Update UI\n  updateMatchesUI(faces, labels, matchedRecs, trackedFaces);\n  \n  const now = human.now();\n  timestamp.detect = now;\n  requestAnimationFrame(detectionLoop);\n}\n\nfunction updateMatchesUI(faces: H.FaceResult[], labels: string[], matchedRecs: Array<indexDb.FaceRecord | null>, trackedFaces: TrackedFace[]) {\n  if (!dom.matches) return;\n  \n  dom.matches.innerHTML = '';\n  \n  if (faces.length === 0) {\n    dom.matches.innerText = 'no faces detected';\n    return;\n  }\n  \n  faces.forEach((f, i) => {\n    const row = document.createElement('div');\n    row.style.display = 'flex';\n    row.style.alignItems = 'center';\n    row.style.gap = '8px';\n    row.style.margin = '4px 0';\n    \n    const text = document.createElement('div');\n    text.innerText = `face ${i + 1}: ${labels[i] || 'unknown'}`;\n    row.appendChild(text);\n    \n    // Find tracked face info\n    const tracked = trackedFaces.find(tf => \n      tf.face.box && f.box && \n      Math.abs(tf.face.box[0] - f.box[0]) < 50 && \n      Math.abs(tf.face.box[1] - f.box[1]) < 50\n    );\n    \n    // Show tracking status\n    if (tracked && !tracked.isMatched) {\n      const status = document.createElement('div');\n      status.style.fontSize = '12px';\n      status.style.color = '#888';\n      const remaining = Math.max(0, 5000 - tracked.trackingDuration);\n      status.innerText = `(${(remaining / 1000).toFixed(1)}\uCD08 \uD6C4 \uC790\uB3D9 \uB4F1\uB85D)`;\n      row.appendChild(status);\n    }\n    \n    // Live crop from video\n    if (f.box && dom.video.videoWidth > 0) {\n      const [bx, by, bw, bh] = f.box as [number, number, number, number];\n      const sx = Math.max(0, Math.floor(bx));\n      const sy = Math.max(0, Math.floor(by));\n      const sw = Math.min(dom.video.videoWidth - sx, Math.floor(bw));\n      const sh = Math.min(dom.video.videoHeight - sy, Math.floor(bh));\n      const live = document.createElement('canvas');\n      live.width = 96; live.height = 96;\n      const lctx = live.getContext('2d');\n      if (lctx && sw > 0 && sh > 0) lctx.drawImage(dom.video, sx, sy, sw, sh, 0, 0, 96, 96);\n      row.appendChild(live);\n    }\n    \n    // Show stored image if matched\n    const rec = matchedRecs[i];\n    if (rec?.image) {\n      const c = document.createElement('canvas');\n      c.width = rec.image.width;\n      c.height = rec.image.height;\n      c.style.width = '96px';\n      c.style.height = '96px';\n      const cctx = c.getContext('2d');\n      cctx?.putImageData(rec.image, 0, 0);\n      row.appendChild(c);\n    }\n    \n    dom.matches.appendChild(row);\n  });\n}\n\n// validation removed\n\nasync function saveRecords() {\n  if (dom.name.value.length > 0) {\n    // choose the largest detected face for saving\n    const faces = human.result.face;\n    const faceToSave = faces.sort((a, b) => (b.box[2] * b.box[3]) - (a.box[2] * a.box[3]))[0];\n    if (!faceToSave?.embedding) { log('no face embedding to save'); return; }\n    const image = getFaceCropImageData(dom.video, faceToSave.box as [number, number, number, number], 128);\n    const rec = { id: 0, name: dom.name.value, descriptor: faceToSave.embedding as number[], image };\n    await indexDb.save(rec);\n    await refreshKnownFaces();\n    log('saved face record:', rec.name, 'descriptor length:', (faceToSave.embedding?.length || 0));\n    log('known face records:', knownFaces.length);\n  } else {\n    log('invalid name');\n  }\n}\n\nasync function deleteRecord() {\n  if (current.record && current.record.id > 0) {\n    await indexDb.remove(current.record);\n    await refreshKnownFaces();\n  }\n}\n\n// detectFace flow removed; handled in detectionLoop per-frame\n\nasync function main() { // main entry point for continuous mode\n  dom.match.style.display = 'flex';\n  dom.save.style.display = 'flex';\n  dom.delete.style.display = 'flex';\n  dom.source.style.display = 'none';\n  dom.canvas.style.height = '';\n  document.body.style.background = 'black';\n  if (dom.video.paused) void dom.video.play();\n  await detectionLoop();\n}\n\nasync function init() {\n  log('human version:', human.version, '| tfjs version:', human.tf.version['tfjs-core']);\n  log('options:', JSON.stringify(options).replace(/{|}|\"|\\[|\\]/g, '').replace(/,/g, ' '));\n  log('initializing webcam...');\n  await webCam(); // start webcam\n  log('loading human models...');\n  await human.load(); // preload all models\n  log('initializing human...');\n  log('loading face database...');\n  await refreshKnownFaces();\n  \n  // Initialize face tracker\n  faceTracker = new FaceTracker(knownDescriptors, knownFaces, matchOptions, human);\n  log('face tracker initialized');\n  \n  dom.save.addEventListener('click', saveRecords);\n  dom.delete.addEventListener('click', deleteRecord);\n  await human.warmup(); // warmup function to initialize backend for future faster detection\n  await main();\n}\n\nwindow.onload = init;\n\nasync function refreshKnownFaces() {\n  knownFaces = await indexDb.load();\n  knownDescriptors = knownFaces.map((rec) => rec.descriptor).filter((d) => d.length > 0);\n  log('known face records:', knownFaces.length);\n}\n", "let db: IDBDatabase; // instance of indexdb\n\nconst database = 'human';\nconst table = 'person';\n\nexport interface FaceRecord { id: number, name: string, descriptor: number[], image: ImageData }\n\nconst log = (...msg) => console.log('indexdb', ...msg); // eslint-disable-line no-console\n\nexport async function open() {\n  if (db) return true;\n  return new Promise((resolve) => {\n    const request: IDBOpenDBRequest = indexedDB.open(database, 1);\n    request.onerror = (evt) => log('error:', evt);\n    request.onupgradeneeded = (evt: IDBVersionChangeEvent) => { // create if doesnt exist\n      log('create:', evt.target);\n      db = (evt.target as IDBOpenDBRequest).result;\n      db.createObjectStore(table, { keyPath: 'id', autoIncrement: true });\n    };\n    request.onsuccess = (evt) => { // open\n      db = (evt.target as IDBOpenDBRequest).result;\n      log('open:', db);\n      resolve(true);\n    };\n  });\n}\n\nexport async function load(): Promise<FaceRecord[]> {\n  const faceDB: FaceRecord[] = [];\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const cursor: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).openCursor(null, 'next');\n    cursor.onerror = (evt) => log('load error:', evt);\n    cursor.onsuccess = (evt) => {\n      if ((evt.target as IDBRequest).result) {\n        faceDB.push((evt.target as IDBRequest).result.value);\n        (evt.target as IDBRequest).result.continue();\n      } else {\n        resolve(faceDB);\n      }\n    };\n  });\n}\n\nexport async function count(): Promise<number> {\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const store: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).count();\n    store.onerror = (evt) => log('count error:', evt);\n    store.onsuccess = () => resolve(store.result);\n  });\n}\n\nexport async function save(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  const newRecord = { name: faceRecord.name, descriptor: faceRecord.descriptor, image: faceRecord.image }; // omit id as its autoincrement\n  db.transaction([table], 'readwrite').objectStore(table).put(newRecord);\n  log('save:', newRecord);\n}\n\nexport async function remove(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  db.transaction([table], 'readwrite').objectStore(table).delete(faceRecord.id); // delete based on id\n  log('delete:', faceRecord);\n}\n", "/**\n * Face tracking system for automatic registration\n */\n\nimport * as H from '../../dist/human.esm.js';\nimport * as indexDb from './indexdb';\n\nexport interface TrackedFace {\n  id: string;\n  face: H.FaceResult;\n  firstSeen: number;\n  lastSeen: number;\n  trackingDuration: number;\n  isMatched: boolean;\n  matchedRecord?: indexDb.FaceRecord;\n}\n\nexport class FaceTracker {\n  private trackedFaces = new Map<string, TrackedFace>();\n  private readonly trackingThreshold = 5000; // 5 seconds\n  private readonly similarityThreshold = 0.6; // threshold for considering faces as same person\n  private readonly autoSaveEnabled = true;\n\n  constructor(\n    private knownDescriptors: number[][],\n    private knownFaces: indexDb.FaceRecord[],\n    private matchOptions: H.match.MatchOptions,\n    private human: H.Human\n  ) {}\n\n  updateKnownFaces(descriptors: number[][], faces: indexDb.FaceRecord[]) {\n    this.knownDescriptors = descriptors;\n    this.knownFaces = faces;\n  }\n\n  private generateFaceId(face: H.FaceResult): string {\n    // Generate simple ID based on face position and size\n    if (!face.box) return Math.random().toString();\n    const [x, y, w, h] = face.box;\n    return `${Math.round(x)}_${Math.round(y)}_${Math.round(w)}_${Math.round(h)}`;\n  }\n\n  private isSameFace(face1: H.FaceResult, face2: H.FaceResult): boolean {\n    if (!face1.box || !face2.box) return false;\n    \n    const [x1, y1, w1, h1] = face1.box;\n    const [x2, y2, w2, h2] = face2.box;\n    \n    // Check if faces are in similar position and size\n    const positionThreshold = 50;\n    const sizeThreshold = 30;\n    \n    return Math.abs(x1 - x2) < positionThreshold &&\n           Math.abs(y1 - y2) < positionThreshold &&\n           Math.abs(w1 - w2) < sizeThreshold &&\n           Math.abs(h1 - h2) < sizeThreshold;\n  }\n\n  private findMatchingKnownFace(face: H.FaceResult): { record: indexDb.FaceRecord; similarity: number } | null {\n    if (!face.embedding || face.embedding.length === 0 || this.knownDescriptors.length === 0) {\n      return null;\n    }\n\n    const res = this.human.match.find(face.embedding, this.knownDescriptors, this.matchOptions);\n    const record = this.knownFaces[res.index];\n    \n    if (record && res.similarity > this.similarityThreshold) { // threshold for considering a match\n      return { record, similarity: res.similarity };\n    }\n    \n    return null;\n  }\n\n  async processFaces(faces: H.FaceResult[]): Promise<{ newlyRegistered: TrackedFace[], updates: TrackedFace[] }> {\n    const now = Date.now();\n    const currentFaceIds = new Set<string>();\n    const newlyRegistered: TrackedFace[] = [];\n    const updates: TrackedFace[] = [];\n\n    // Process each detected face\n    for (const face of faces) {\n      if (!face.embedding || face.embedding.length === 0) continue;\n\n      // Check if face matches known faces\n      const matchResult = this.findMatchingKnownFace(face);\n      const isMatched = matchResult !== null;\n\n      // Find existing tracked face or create new one\n      let trackedFace: TrackedFace | null = null;\n      \n      // Try to find existing tracked face by similarity\n      for (const [id, tracked] of this.trackedFaces) {\n        if (this.isSameFace(face, tracked.face)) {\n          trackedFace = tracked;\n          currentFaceIds.add(id);\n          break;\n        }\n      }\n\n      if (!trackedFace) {\n        // Create new tracked face\n        const id = this.generateFaceId(face);\n        trackedFace = {\n          id,\n          face,\n          firstSeen: now,\n          lastSeen: now,\n          trackingDuration: 0,\n          isMatched,\n          matchedRecord: matchResult?.record\n        };\n        this.trackedFaces.set(id, trackedFace);\n        currentFaceIds.add(id);\n      } else {\n        // Update existing tracked face\n        trackedFace.face = face;\n        trackedFace.lastSeen = now;\n        trackedFace.trackingDuration = now - trackedFace.firstSeen;\n        trackedFace.isMatched = isMatched;\n        trackedFace.matchedRecord = matchResult?.record;\n      }\n\n      // Check if unknown face should be auto-registered\n      if (!trackedFace.isMatched && \n          trackedFace.trackingDuration >= this.trackingThreshold && \n          this.autoSaveEnabled) {\n        \n        await this.autoRegisterFace(trackedFace);\n        newlyRegistered.push(trackedFace);\n      }\n\n      updates.push(trackedFace);\n    }\n\n    // Remove faces that are no longer detected\n    for (const [id, tracked] of this.trackedFaces) {\n      if (!currentFaceIds.has(id)) {\n        // Face not seen for a while, remove it\n        if (now - tracked.lastSeen > 2000) { // 2 second timeout\n          this.trackedFaces.delete(id);\n        }\n      }\n    }\n\n    return { newlyRegistered, updates };\n  }\n\n  private async autoRegisterFace(trackedFace: TrackedFace) {\n    try {\n      // Generate automatic name\n      const timestamp = new Date().toLocaleString('ko-KR');\n      const autoName = `Unknown_${timestamp}`;\n\n      // Get face crop for image storage\n      const image = this.getFaceCropImageData(trackedFace.face);\n      \n      const record: indexDb.FaceRecord = {\n        id: 0, // will be auto-incremented\n        name: autoName,\n        descriptor: trackedFace.face.embedding as number[],\n        image\n      };\n\n      await indexDb.save(record);\n      \n      // Mark as matched to prevent re-registration\n      trackedFace.isMatched = true;\n      \n      console.log('Auto-registered face:', autoName);\n    } catch (error) {\n      console.error('Failed to auto-register face:', error);\n    }\n  }\n\n  private getFaceCropImageData(face: H.FaceResult): ImageData {\n    if (!face.box) {\n      // Return empty ImageData if no box\n      const canvas = document.createElement('canvas');\n      canvas.width = canvas.height = 128;\n      const ctx = canvas.getContext('2d')!;\n      return ctx.getImageData(0, 0, 128, 128);\n    }\n\n    const video = document.getElementById('video') as HTMLVideoElement;\n    const [bx, by, bw, bh] = face.box as [number, number, number, number];\n    const sx = Math.max(0, Math.floor(bx));\n    const sy = Math.max(0, Math.floor(by));\n    const sw = Math.max(1, Math.min(video.videoWidth - sx, Math.floor(bw)));\n    const sh = Math.max(1, Math.min(video.videoHeight - sy, Math.floor(bh)));\n    \n    const canvas = document.createElement('canvas');\n    canvas.width = canvas.height = 128;\n    const ctx = canvas.getContext('2d')!;\n    \n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high';\n    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, 128, 128);\n    \n    return ctx.getImageData(0, 0, 128, 128);\n  }\n\n  getTrackedFaces(): TrackedFace[] {\n    return Array.from(this.trackedFaces.values());\n  }\n\n  getTrackingInfo(faceId: string): TrackedFace | null {\n    return this.trackedFaces.get(faceId) || null;\n  }\n}"],
  "mappings": "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",
  "names": ["knownDescriptors", "knownFaces", "matchOptions", "human", "timestamp", "canvas", "ctx", "log", "_a"]
}
