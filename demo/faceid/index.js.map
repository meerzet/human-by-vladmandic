{
  "version": 3,
  "sources": ["index.ts", "indexdb.ts"],
  "sourcesContent": ["/**\n * Human demo for browsers\n * @default Human Library\n * @summary <https://github.com/vladmandic/human>\n * @author <https://github.com/vladmandic>\n * @copyright <https://github.com/vladmandic>\n * @license MIT\n */\n\nimport * as H from '../../dist/human.esm.js'; // equivalent of @vladmandic/Human\nimport * as indexDb from './indexdb'; // methods to deal with indexdb\n\nconst humanConfig: Partial<H.Config> = { // user configuration for human, used to fine-tune behavior\n  cacheSensitivity: 0.01,\n  modelBasePath: '../../models',\n  filter: { enabled: true, equalization: true }, // lets run with histogram equilizer\n  backend: 'humangl',\n  debug: true,\n  face: {\n    enabled: true,\n    detector: { maxDetected: 3, rotation: true, return: false, mask: false }, // no need to return tensors in realtime mode\n    description: { enabled: true }, // default model for face descriptor extraction is faceres\n    // mobilefacenet: { enabled: true, modelPath: 'https://vladmandic.github.io/human-models/models/mobilefacenet.json' }, // alternative model\n    // insightface: { enabled: true, modelPath: 'https://vladmandic.github.io/insightface/models/insightface-mobilenet-swish.json' }, // alternative model\n    iris: { enabled: false }, // iris disabled: operate without gaze/gesture\n    emotion: { enabled: false }, // not needed\n    // antispoof: { enabled: true }, // enable optional antispoof module\n    // liveness: { enabled: true }, // enable optional liveness module\n  },\n  body: { enabled: false },\n  hand: { enabled: false },\n  object: { enabled: false },\n  // gesture: { enabled: true }, // parses face and iris gestures\n};\n\n// const matchOptions = { order: 2, multiplier: 1000, min: 0.0, max: 1.0 }; // for embedding model\nconst matchOptions = { order: 2, multiplier: 25, min: 0.2, max: 0.8 }; // for faceres model\n\nconst options = {\n  minConfidence: 0.6, // overal face confidence for box, face, gender, real, live\n  minSize: 224, // min input to face descriptor model before degradation\n  maxTime: 30000, // max time before giving up\n  blinkMin: 10, // minimum duration of a valid blink\n  blinkMax: 800, // maximum duration of a valid blink\n  threshold: 0.5, // minimum similarity\n  distanceMin: 0.4, // closest that face is allowed to be to the cammera in cm\n  distanceMax: 1.0, // farthest that face is allowed to be to the cammera in cm\n  mask: humanConfig.face?.detector?.mask,\n  rotation: humanConfig.face?.detector?.rotation,\n  ...matchOptions,\n};\n\n// Real-time mode: validation gates removed\n\nconst current: { face: H.FaceResult | null, record: indexDb.FaceRecord | null } = { face: null, record: null }; // backward-compatible current selection\nlet knownFaces: indexDb.FaceRecord[] = [];\nlet knownDescriptors: number[][] = [];\n\n// gesture/iris disabled: remove blink and gaze-related state\n\n// let db: Array<{ name: string, source: string, embedding: number[] }> = []; // holds loaded face descriptor database\nconst human = new H.Human(humanConfig); // create instance of human with overrides from user configuration\n\nhuman.env.perfadd = false; // is performance data showing instant or total values\nhuman.draw.options.font = 'small-caps 18px \"Lato\"'; // set font used to draw labels when using draw methods\nhuman.draw.options.lineHeight = 20;\n\nconst dom = { // grab instances of dom objects so we dont have to look them up later\n  video: document.getElementById('video') as HTMLVideoElement,\n  canvas: document.getElementById('canvas') as HTMLCanvasElement,\n  log: document.getElementById('log') as HTMLPreElement,\n  fps: document.getElementById('fps') as HTMLPreElement,\n  match: document.getElementById('match') as HTMLDivElement,\n  matches: document.getElementById('matches') as HTMLDivElement,\n  name: document.getElementById('name') as HTMLInputElement,\n  save: document.getElementById('save') as HTMLSpanElement,\n  delete: document.getElementById('delete') as HTMLSpanElement,\n  source: document.getElementById('source') as HTMLCanvasElement,\n};\nconst timestamp = { detect: 0, draw: 0 }; // holds information used to calculate performance and possible memory leaks\nlet startTime = 0;\n\nconst log = (...msg) => { // helper method to output messages\n  dom.log.innerText += msg.join(' ') + '\\n';\n  console.log(...msg); // eslint-disable-line no-console\n};\n\nfunction drawFaceCrop(ctx: CanvasRenderingContext2D, video: HTMLVideoElement, box: [number, number, number, number], destX: number, destY: number, size = 96) {\n  const [bx, by, bw, bh] = box;\n  const sx = Math.max(0, Math.floor(bx));\n  const sy = Math.max(0, Math.floor(by));\n  const sw = Math.max(1, Math.min(video.videoWidth - sx, Math.floor(bw)));\n  const sh = Math.max(1, Math.min(video.videoHeight - sy, Math.floor(bh)));\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n  ctx.drawImage(video, sx, sy, sw, sh, destX, Math.max(0, destY), size, size);\n  ctx.strokeStyle = 'white';\n  ctx.lineWidth = 1;\n  ctx.strokeRect(destX - 0.5, Math.max(0, destY) - 0.5, size + 1, size + 1);\n}\n\nfunction getFaceCropImageData(video: HTMLVideoElement, box: [number, number, number, number], size = 128): ImageData {\n  const [bx, by, bw, bh] = box;\n  const sx = Math.max(0, Math.floor(bx));\n  const sy = Math.max(0, Math.floor(by));\n  const sw = Math.max(1, Math.min(video.videoWidth - sx, Math.floor(bw)));\n  const sh = Math.max(1, Math.min(video.videoHeight - sy, Math.floor(bh)));\n  const off = document.createElement('canvas');\n  off.width = size; off.height = size;\n  const octx = off.getContext('2d') as CanvasRenderingContext2D;\n  octx.imageSmoothingEnabled = true;\n  octx.imageSmoothingQuality = 'high';\n  octx.drawImage(video, sx, sy, sw, sh, 0, 0, size, size);\n  return octx.getImageData(0, 0, size, size);\n}\n\nasync function webCam() { // initialize webcam\n  // @ts-ignore resizeMode is not yet defined in tslib\n  const cameraOptions: MediaStreamConstraints = { audio: false, video: { facingMode: 'user', resizeMode: 'none', width: { ideal: document.body.clientWidth } } };\n  const stream: MediaStream = await navigator.mediaDevices.getUserMedia(cameraOptions);\n  const ready = new Promise((resolve) => { dom.video.onloadeddata = () => resolve(true); });\n  dom.video.srcObject = stream;\n  void dom.video.play();\n  await ready;\n  // set canvas internal size to match video pixels\n  dom.canvas.width = dom.video.videoWidth;\n  dom.canvas.height = dom.video.videoHeight;\n  // ensure canvas CSS size tracks the video's rendered size\n  const stage = document.getElementById('stage') as HTMLDivElement | null;\n  if (stage) {\n    const resize = () => {\n      // canvas is absolutely positioned with width/height 100% in CSS, so nothing else required\n      // but some browsers need a reflow to sync; toggling transform forces it\n      dom.canvas.style.transform = 'translateZ(0)';\n    };\n    new ResizeObserver(resize).observe(stage);\n    resize();\n  }\n  if (human.env.initial) log('video:', dom.video.videoWidth, dom.video.videoHeight, '|', stream.getVideoTracks()[0].label);\n  dom.canvas.onclick = () => { // pause when clicked on screen and resume on next click\n    if (dom.video.paused) void dom.video.play();\n    else dom.video.pause();\n  };\n}\n\nasync function detectionLoop() { // main detection + render + match loop\n  if (dom.video.paused) return;\n  await human.detect(dom.video);\n  const interpolated = human.next(human.result);\n  const ctx = dom.canvas.getContext('2d');\n  ctx?.clearRect(0, 0, dom.canvas.width, dom.canvas.height);\n  // draw and match up to 3 faces\n  const faces = human.result.face.slice(0, 3);\n  const labels: string[] = [];\n  const matchedRecs: Array<indexDb.FaceRecord | null> = [];\n  if (ctx) {\n    ctx.save();\n    ctx.font = '16px Lato';\n    ctx.fillStyle = 'white';\n    ctx.strokeStyle = 'black';\n    ctx.lineWidth = 2;\n  }\n  let primaryBest = null as null | { name: string, similarity: number, record: indexDb.FaceRecord };\n  for (let i = 0; i < faces.length; i += 1) {\n    const f = faces[i];\n    let label = 'unknown';\n    let matchedRec: indexDb.FaceRecord | null = null;\n    if (f.embedding && f.embedding.length > 0 && knownDescriptors.length > 0) {\n      const res = human.match.find(f.embedding, knownDescriptors, matchOptions);\n      const rec = knownFaces[res.index];\n      if (rec) {\n        matchedRec = rec;\n        label = `${rec.name} (${Math.round(res.similarity * 100)}%)`;\n        if (!primaryBest || res.similarity > primaryBest.similarity) primaryBest = { name: rec.name, similarity: res.similarity, record: rec };\n      } else {\n        label = `unknown (${Math.round(res.similarity * 100)}%)`;\n      }\n    }\n    // draw box and label near face and crop preview above\n    if (ctx && f.box) {\n      const [x, y, w, h] = f.box as [number, number, number, number];\n      ctx.strokeStyle = 'lime';\n      ctx.strokeRect(x, y, w, h);\n      const ty = Math.max(0, y - 6);\n      ctx.strokeStyle = 'black';\n      ctx.strokeText(label, x, ty);\n      ctx.fillText(label, x, ty);\n    }\n    labels.push(label);\n    matchedRecs.push(matchedRec);\n  }\n  // update current selection for save/delete (use primary best match or largest face)\n  current.face = faces.sort((a, b) => (b.box[2] * b.box[3]) - (a.box[2] * a.box[3]))[0] || null;\n  current.record = primaryBest ? primaryBest.record : null;\n  // update matches list UI\n  if (dom.matches) {\n    dom.matches.innerHTML = '';\n    faces.forEach((f, i) => {\n      const row = document.createElement('div');\n      row.style.display = 'flex';\n      row.style.alignItems = 'center';\n      row.style.gap = '8px';\n      row.style.margin = '4px 0';\n      const text = document.createElement('div');\n      text.innerText = `face ${i + 1}: ${labels[i] || 'unknown'}`;\n      row.appendChild(text);\n      // live crop from video\n      if (f.box && dom.video.videoWidth > 0) {\n        const [bx, by, bw, bh] = f.box as [number, number, number, number];\n        const sx = Math.max(0, Math.floor(bx));\n        const sy = Math.max(0, Math.floor(by));\n        const sw = Math.min(dom.video.videoWidth - sx, Math.floor(bw));\n        const sh = Math.min(dom.video.videoHeight - sy, Math.floor(bh));\n        const live = document.createElement('canvas');\n        live.width = 96; live.height = 96;\n        const lctx = live.getContext('2d');\n        if (lctx && sw > 0 && sh > 0) lctx.drawImage(dom.video, sx, sy, sw, sh, 0, 0, 96, 96);\n        row.appendChild(live);\n      }\n      const rec = matchedRecs[i];\n      if (rec?.image) {\n        const c = document.createElement('canvas');\n        c.width = rec.image.width;\n        c.height = rec.image.height;\n        c.style.width = '96px';\n        c.style.height = '96px';\n        const cctx = c.getContext('2d');\n        cctx?.putImageData(rec.image, 0, 0);\n        row.appendChild(c);\n      }\n      dom.matches.appendChild(row);\n    });\n    if (faces.length === 0) dom.matches.innerText = 'no faces detected';\n  }\n  const now = human.now();\n  timestamp.detect = now;\n  requestAnimationFrame(detectionLoop);\n}\n\n// validation removed\n\nasync function saveRecords() {\n  if (dom.name.value.length > 0) {\n    // choose the largest detected face for saving\n    const faces = human.result.face;\n    const faceToSave = faces.sort((a, b) => (b.box[2] * b.box[3]) - (a.box[2] * a.box[3]))[0];\n    if (!faceToSave?.embedding) { log('no face embedding to save'); return; }\n    const image = getFaceCropImageData(dom.video, faceToSave.box as [number, number, number, number], 128);\n    const rec = { id: 0, name: dom.name.value, descriptor: faceToSave.embedding as number[], image };\n    await indexDb.save(rec);\n    await refreshKnownFaces();\n    log('saved face record:', rec.name, 'descriptor length:', (faceToSave.embedding?.length || 0));\n    log('known face records:', knownFaces.length);\n  } else {\n    log('invalid name');\n  }\n}\n\nasync function deleteRecord() {\n  if (current.record && current.record.id > 0) {\n    await indexDb.remove(current.record);\n    await refreshKnownFaces();\n  }\n}\n\n// detectFace flow removed; handled in detectionLoop per-frame\n\nasync function main() { // main entry point for continuous mode\n  dom.match.style.display = 'flex';\n  dom.save.style.display = 'flex';\n  dom.delete.style.display = 'flex';\n  dom.source.style.display = 'none';\n  dom.canvas.style.height = '';\n  document.body.style.background = 'black';\n  if (dom.video.paused) void dom.video.play();\n  await detectionLoop();\n}\n\nasync function init() {\n  log('human version:', human.version, '| tfjs version:', human.tf.version['tfjs-core']);\n  log('options:', JSON.stringify(options).replace(/{|}|\"|\\[|\\]/g, '').replace(/,/g, ' '));\n  log('initializing webcam...');\n  await webCam(); // start webcam\n  log('loading human models...');\n  await human.load(); // preload all models\n  log('initializing human...');\n  // log('face embedding model:', humanConfig.face.description.enabled ? 'faceres' : '', humanConfig.face['mobilefacenet']?.enabled ? 'mobilefacenet' : '', humanConfig.face['insightface']?.enabled ? 'insightface' : '');\n  log('loading face database...');\n  await refreshKnownFaces();\n  dom.save.addEventListener('click', saveRecords);\n  dom.delete.addEventListener('click', deleteRecord);\n  await human.warmup(); // warmup function to initialize backend for future faster detection\n  await main();\n}\n\nwindow.onload = init;\n\nasync function refreshKnownFaces() {\n  knownFaces = await indexDb.load();\n  knownDescriptors = knownFaces.map((rec) => rec.descriptor).filter((d) => d.length > 0);\n  log('known face records:', knownFaces.length);\n}\n", "let db: IDBDatabase; // instance of indexdb\n\nconst database = 'human';\nconst table = 'person';\n\nexport interface FaceRecord { id: number, name: string, descriptor: number[], image: ImageData }\n\nconst log = (...msg) => console.log('indexdb', ...msg); // eslint-disable-line no-console\n\nexport async function open() {\n  if (db) return true;\n  return new Promise((resolve) => {\n    const request: IDBOpenDBRequest = indexedDB.open(database, 1);\n    request.onerror = (evt) => log('error:', evt);\n    request.onupgradeneeded = (evt: IDBVersionChangeEvent) => { // create if doesnt exist\n      log('create:', evt.target);\n      db = (evt.target as IDBOpenDBRequest).result;\n      db.createObjectStore(table, { keyPath: 'id', autoIncrement: true });\n    };\n    request.onsuccess = (evt) => { // open\n      db = (evt.target as IDBOpenDBRequest).result;\n      log('open:', db);\n      resolve(true);\n    };\n  });\n}\n\nexport async function load(): Promise<FaceRecord[]> {\n  const faceDB: FaceRecord[] = [];\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const cursor: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).openCursor(null, 'next');\n    cursor.onerror = (evt) => log('load error:', evt);\n    cursor.onsuccess = (evt) => {\n      if ((evt.target as IDBRequest).result) {\n        faceDB.push((evt.target as IDBRequest).result.value);\n        (evt.target as IDBRequest).result.continue();\n      } else {\n        resolve(faceDB);\n      }\n    };\n  });\n}\n\nexport async function count(): Promise<number> {\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const store: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).count();\n    store.onerror = (evt) => log('count error:', evt);\n    store.onsuccess = () => resolve(store.result);\n  });\n}\n\nexport async function save(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  const newRecord = { name: faceRecord.name, descriptor: faceRecord.descriptor, image: faceRecord.image }; // omit id as its autoincrement\n  db.transaction([table], 'readwrite').objectStore(table).put(newRecord);\n  log('save:', newRecord);\n}\n\nexport async function remove(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  db.transaction([table], 'readwrite').objectStore(table).delete(faceRecord.id); // delete based on id\n  log('delete:', faceRecord);\n}\n"],
  "mappings": "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",
  "names": ["log", "log", "_a"]
}
